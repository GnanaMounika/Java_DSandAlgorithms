{\rtf1\ansi\ansicpg1252\cocoartf2709
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 HelveticaNeue;\f1\fnil\fcharset0 Menlo-Regular;\f2\fnil\fcharset0 HelveticaNeue-Italic;
\f3\fnil\fcharset0 Menlo-Italic;\f4\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;\red29\green29\blue29;\red236\green236\blue236;\red29\green29\blue29;
\red0\green10\blue24;\red0\green0\blue255;\red255\green255\blue255;\red0\green0\blue0;\red32\green108\blue135;
\red101\green76\blue29;\red0\green0\blue109;\red157\green0\blue210;\red19\green118\blue70;}
{\*\expandedcolortbl;;\cssrgb\c14902\c14902\c14902;\cssrgb\c94118\c94118\c94118;\cssrgb\c14902\c14902\c14902\c74902;
\cssrgb\c0\c3922\c12549\c3137;\cssrgb\c0\c0\c100000;\cssrgb\c100000\c100000\c100000;\cssrgb\c0\c0\c0;\cssrgb\c14902\c49804\c60000;
\cssrgb\c47451\c36863\c14902;\cssrgb\c0\c6275\c50196;\cssrgb\c68627\c0\c85882;\cssrgb\c3529\c52549\c34510;}
\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\partightenfactor0

\f0\fs28 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Given an array of integers\'a0
\f1\fs18 \cf4 \cb5 \strokec4 nums
\f0\fs28 \cf2 \cb3 \strokec2 \'a0and an integer\'a0
\f1\fs18 \cf4 \cb5 \strokec4 target
\f0\fs28 \cf2 \cb3 \strokec2 , return\'a0
\f2\i indices of the two numbers such that they add up to\'a0
\f3\fs18 \cf4 \cb5 \strokec4 target
\f0\i0\fs28 \cf2 \cb3 \strokec2 .
\f4\fs24 \cf0 \cb1 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 /\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 \
/two pass hash map , add into hash map and check for target, hash map has O(1) lookup if there is no collision so..\
\pard\pardeftab720\partightenfactor0

\f1\fs26 \cf6 \cb7 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec6 class\cf0 \strokec8  \cf9 \strokec9 Solution\cf0 \strokec8  \{\cb1 \
\pard\pardeftab720\partightenfactor0
\cf0 \cb7     \cf6 \strokec6 public\cf0 \strokec8  \cf9 \strokec9 int\cf0 \strokec8 [] \cf10 \strokec10 twoSum\cf0 \strokec8 (\cf9 \strokec9 int\cf0 \strokec8 [] \cf11 \strokec11 nums\cf0 \strokec8 , \cf9 \strokec9 int\cf0 \strokec8  \cf11 \strokec11 target\cf0 \strokec8 ) \{\cb1 \
\pard\pardeftab720\partightenfactor0
\cf9 \cb7 \strokec9 Map\cf0 \strokec8  <\cf9 \strokec9 Integer\cf0 \strokec8 , \cf9 \strokec9 Integer\cf0 \strokec8 > \cf11 \strokec11 map\cf0 \strokec8  = \cf12 \strokec12 new\cf0 \strokec8  \cf9 \strokec9 HashMap\cf0 \strokec8 <>();\cb1 \
\pard\pardeftab720\partightenfactor0
\cf12 \cb7 \strokec12 for\cf0 \strokec8 (\cf9 \strokec9 int\cf0 \strokec8  \cf11 \strokec11 i\cf0 \strokec8  = \cf13 \strokec13 0\cf0 \strokec8 ;i< \cf11 \strokec11 nums\cf0 \strokec8 .\cf11 \strokec11 length\cf0 \strokec8 ;i++)\{\cb1 \
\pard\pardeftab720\partightenfactor0
\cf0 \cb7     \cf11 \strokec11 map\cf0 \strokec8 .\cf10 \strokec10 put\cf0 \strokec8 (nums[i],i); \cb1 \
\cb7 \}\cb1 \
\pard\pardeftab720\partightenfactor0
\cf12 \cb7 \strokec12 for\cf0 \strokec8  (\cf9 \strokec9 int\cf0 \strokec8  \cf11 \strokec11 i\cf0 \strokec8  = \cf13 \strokec13 0\cf0 \strokec8 ;i< \cf11 \strokec11 nums\cf0 \strokec8 .\cf11 \strokec11 length\cf0 \strokec8 ;i++)\{\cb1 \
\pard\pardeftab720\partightenfactor0
\cf0 \cb7     \cf9 \strokec9 int\cf0 \strokec8  \cf11 \strokec11 complement\cf0 \strokec8  = target - nums[i];\cb1 \
\pard\pardeftab720\partightenfactor0
\cf12 \cb7 \strokec12 if\cf0 \strokec8 (\cf11 \strokec11 map\cf0 \strokec8 .\cf10 \strokec10 containsKey\cf0 \strokec8 (complement) && \cf11 \strokec11 map\cf0 \strokec8 .\cf10 \strokec10 get\cf0 \strokec8 (complement)!= i)\{\cb1 \
\pard\pardeftab720\partightenfactor0
\cf0 \cb7     \cf12 \strokec12 return\cf0 \strokec8  \cf12 \strokec12 new\cf0 \strokec8  \cf9 \strokec9 int\cf0 \strokec8  [] \{i,\cf11 \strokec11 map\cf0 \strokec8 .\cf10 \strokec10 get\cf0 \strokec8 (complement)\};\cb1 \
\cb7 \}\cb1 \
\cb7 \}\cb1 \
\pard\pardeftab720\partightenfactor0
\cf12 \cb7 \strokec12 return\cf0 \strokec8  \cf6 \strokec6 null\cf0 \strokec8 ;\cb1 \
\pard\pardeftab720\partightenfactor0
\cf0 \cb7     \}\cb1 \
\cb7 \}\cb1 \
// one pass hash map.. before inserting itself we need to check if the complacent exists since there I sonly one solution.\
class Solution \{\
    public int[] twoSum(int[] nums, int target) \{\
        Map<Integer, Integer> map = new HashMap<>();\
        for (int i = 0; i < nums.length; i++) \{\
            map.put(nums[i], i);\
        \}\
        for (int i = 0; i < nums.length; i++) \{\
            int complement = target - nums[i];\
            if (map.containsKey(complement) && map.get(complement) != i) \{\
                return new int[] \{ i, map.get(complement) \};\
            \}\
        \}\
        // In case there is no solution, we'll just return null\
        return null;\
    \}\
\}\
\
******************************************************************\
If the array is already sorted we can use two pointers technique\
\pard\pardeftab720\partightenfactor0
\cf6 \cb7 \strokec6 class\cf0 \strokec8  \cf9 \strokec9 Solution\cf0 \strokec8  \{\cb1 \
\pard\pardeftab720\partightenfactor0
\cf0 \cb7     \cf6 \strokec6 public\cf0 \strokec8  \cf9 \strokec9 int\cf0 \strokec8 [] \cf10 \strokec10 twoSum\cf0 \strokec8 (\cf9 \strokec9 int\cf0 \strokec8 [] \cf11 \strokec11 numbers\cf0 \strokec8 , \cf9 \strokec9 int\cf0 \strokec8  \cf11 \strokec11 target\cf0 \strokec8 ) \{\cb1 \
\cb7        \cf9 \strokec9 int\cf0 \strokec8  \cf11 \strokec11 i\cf0 \strokec8 =\cf13 \strokec13 0\cf0 \strokec8 ,j= \cf11 \strokec11 numbers\cf0 \strokec8 .\cf11 \strokec11 length\cf0 \strokec8 -\cf13 \strokec13 1\cf0 \strokec8 ;\cb1 \
\
\cb7         \cf12 \strokec12 while\cf0 \strokec8 (i  < \cf11 \strokec11 numbers\cf0 \strokec8 .\cf11 \strokec11 length\cf0 \strokec8  && j >= \cf13 \strokec13 0\cf0 \strokec8  )\{\cb1 \
\cb7          \cf12 \strokec12 if\cf0 \strokec8 (numbers[i] + numbers[j] == target)\cb1 \
\cb7          \cf12 \strokec12 return\cf0 \strokec8  \cf12 \strokec12 new\cf0 \strokec8  \cf9 \strokec9 int\cf0 \strokec8 []\{i+\cf13 \strokec13 1\cf0 \strokec8 ,j+\cf13 \strokec13 1\cf0 \strokec8 \};\cb1 \
\cb7          \cf12 \strokec12 if\cf0 \strokec8 (target - numbers[j] > numbers[i])\{\cb1 \
\cb7             i++;\cb1 \
\cb7          \}\cb1 \
\cb7          \cf12 \strokec12 if\cf0 \strokec8 (target - numbers[i] < numbers[j])\cb1 \
\cb7          \{\cb1 \
\cb7             j--;\cb1 \
\cb7          \}\cb1 \
\
\cb7         \cb1 \
\cb7         \cb1 \
\cb7         \}\cb1 \
\cb7         \cf12 \strokec12 return\cf0 \strokec8  \cf12 \strokec12 new\cf0 \strokec8  \cf9 \strokec9 int\cf0 \strokec8 []\{-\cf13 \strokec13 1\cf0 \strokec8 ,-\cf13 \strokec13 1\cf0 \strokec8 \};\cb1 \
\cb7     \}\cb1 \
\cb7 \}\cb1 \
\
}